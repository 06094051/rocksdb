/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef leveldb_TYPES_H
#define leveldb_TYPES_H

#include <Thrift.h>
#include <TApplicationException.h>
#include <protocol/TProtocol.h>
#include <transport/TTransport.h>

namespace apache { namespace thrift { namespace reflection {
class Schema;
}}}


namespace Tleveldb {

enum CompressionType {
  kNoCompression = 0,
  kSnappyCompression = 1
};

extern const std::map<int, const char*> _CompressionType_VALUES_TO_NAMES;

extern const std::map<const char*, int, apache::thrift::ltstr> _CompressionType_NAMES_TO_VALUES;

} // namespace
namespace apache { namespace thrift { 
template<>
inline constexpr  ::Tleveldb::CompressionType TEnumTraits< ::Tleveldb::CompressionType>::min() {
return  ::Tleveldb::CompressionType::kNoCompression;
}
template<>
inline constexpr  ::Tleveldb::CompressionType TEnumTraits< ::Tleveldb::CompressionType>::max() {
return  ::Tleveldb::CompressionType::kSnappyCompression;
}
}} // apache:thrift

namespace Tleveldb {
enum Code {
  kOk = 0,
  kNotFound = 1,
  kCorruption = 2,
  kNotSupported = 3,
  kInvalidArgument = 4,
  kIOError = 5,
  kEnd = 6
};

extern const std::map<int, const char*> _Code_VALUES_TO_NAMES;

extern const std::map<const char*, int, apache::thrift::ltstr> _Code_NAMES_TO_VALUES;

} // namespace
namespace apache { namespace thrift { 
template<>
inline constexpr  ::Tleveldb::Code TEnumTraits< ::Tleveldb::Code>::min() {
return  ::Tleveldb::Code::kOk;
}
template<>
inline constexpr  ::Tleveldb::Code TEnumTraits< ::Tleveldb::Code>::max() {
return  ::Tleveldb::Code::kEnd;
}
}} // apache:thrift

namespace Tleveldb {
enum IteratorType {
  seekToFirst = 0,
  seekToLast = 1,
  seekToKey = 2
};

extern const std::map<int, const char*> _IteratorType_VALUES_TO_NAMES;

extern const std::map<const char*, int, apache::thrift::ltstr> _IteratorType_NAMES_TO_VALUES;

} // namespace
namespace apache { namespace thrift { 
template<>
inline constexpr  ::Tleveldb::IteratorType TEnumTraits< ::Tleveldb::IteratorType>::min() {
return  ::Tleveldb::IteratorType::seekToFirst;
}
template<>
inline constexpr  ::Tleveldb::IteratorType TEnumTraits< ::Tleveldb::IteratorType>::max() {
return  ::Tleveldb::IteratorType::seekToKey;
}
}} // apache:thrift

namespace Tleveldb {
typedef std::string Text;

typedef std::string Bytes;

class Slice {
 public:

  static const uint64_t _reflection_id = 2199896239461470156U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  Slice() : data(""), size(0) {
  }

  Slice(const Slice&) = default;
  Slice& operator=(const Slice&) = default;
  Slice(Slice&&) = default;
  Slice& operator=(Slice&&) = default;

  void __clear() {
    data = "";
    size = 0;
    __isset.__clear();
  }

  virtual ~Slice() throw() {}

  Text data;
  int32_t size;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      data = false;
      size = false;
    }
    bool data;
    bool size;
  } __isset;

  bool operator == (const Slice & rhs) const
  {
    if (!(this->data == rhs.data))
      return false;
    if (!(this->size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const Slice &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Slice & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class Slice;
void swap(Slice &a, Slice &b);

class Range {
 public:

  static const uint64_t _reflection_id = 6170219570187881516U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  Range() {
  }

  Range(const Range&) = default;
  Range& operator=(const Range&) = default;
  Range(Range&&) = default;
  Range& operator=(Range&&) = default;

  void __clear() {
    start.__clear();
    limit.__clear();
    __isset.__clear();
  }

  virtual ~Range() throw() {}

  Slice start;
  Slice limit;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      start = false;
      limit = false;
    }
    bool start;
    bool limit;
  } __isset;

  bool operator == (const Range & rhs) const
  {
    if (!(this->start == rhs.start))
      return false;
    if (!(this->limit == rhs.limit))
      return false;
    return true;
  }
  bool operator != (const Range &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Range & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class Range;
void swap(Range &a, Range &b);

class DBOptions {
 public:

  static const uint64_t _reflection_id = 6731746507948871532U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  DBOptions() : create_if_missing(0), error_if_exists(0), write_buffer_size(0), max_open_files(0), block_size(0), block_restart_interval(0), compression(static_cast<CompressionType>(0)) {
  }

  DBOptions(const DBOptions&) = default;
  DBOptions& operator=(const DBOptions&) = default;
  DBOptions(DBOptions&&) = default;
  DBOptions& operator=(DBOptions&&) = default;

  void __clear() {
    create_if_missing = 0;
    error_if_exists = 0;
    write_buffer_size = 0;
    max_open_files = 0;
    block_size = 0;
    block_restart_interval = 0;
    compression = static_cast<CompressionType>(0);
    __isset.__clear();
  }

  virtual ~DBOptions() throw() {}

  bool create_if_missing;
  bool error_if_exists;
  int32_t write_buffer_size;
  int32_t max_open_files;
  int32_t block_size;
  int32_t block_restart_interval;
  CompressionType compression;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      create_if_missing = false;
      error_if_exists = false;
      write_buffer_size = false;
      max_open_files = false;
      block_size = false;
      block_restart_interval = false;
      compression = false;
    }
    bool create_if_missing;
    bool error_if_exists;
    bool write_buffer_size;
    bool max_open_files;
    bool block_size;
    bool block_restart_interval;
    bool compression;
  } __isset;

  bool operator == (const DBOptions & rhs) const
  {
    if (!(this->create_if_missing == rhs.create_if_missing))
      return false;
    if (!(this->error_if_exists == rhs.error_if_exists))
      return false;
    if (!(this->write_buffer_size == rhs.write_buffer_size))
      return false;
    if (!(this->max_open_files == rhs.max_open_files))
      return false;
    if (!(this->block_size == rhs.block_size))
      return false;
    if (!(this->block_restart_interval == rhs.block_restart_interval))
      return false;
    if (!(this->compression == rhs.compression))
      return false;
    return true;
  }
  bool operator != (const DBOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DBOptions & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class DBOptions;
void swap(DBOptions &a, DBOptions &b);

class WriteOptions {
 public:

  static const uint64_t _reflection_id = 8830325115029814540U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  WriteOptions() : sync(0) {
  }

  WriteOptions(const WriteOptions&) = default;
  WriteOptions& operator=(const WriteOptions&) = default;
  WriteOptions(WriteOptions&&) = default;
  WriteOptions& operator=(WriteOptions&&) = default;

  void __clear() {
    sync = 0;
    __isset.__clear();
  }

  virtual ~WriteOptions() throw() {}

  bool sync;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      sync = false;
    }
    bool sync;
  } __isset;

  bool operator == (const WriteOptions & rhs) const
  {
    if (!(this->sync == rhs.sync))
      return false;
    return true;
  }
  bool operator != (const WriteOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WriteOptions & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class WriteOptions;
void swap(WriteOptions &a, WriteOptions &b);

class Snapshot {
 public:

  static const uint64_t _reflection_id = 15670548806217660204U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  Snapshot() : snapshotid(0) {
  }

  Snapshot(const Snapshot&) = default;
  Snapshot& operator=(const Snapshot&) = default;
  Snapshot(Snapshot&&) = default;
  Snapshot& operator=(Snapshot&&) = default;

  void __clear() {
    snapshotid = 0;
    __isset.__clear();
  }

  virtual ~Snapshot() throw() {}

  int64_t snapshotid;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      snapshotid = false;
    }
    bool snapshotid;
  } __isset;

  bool operator == (const Snapshot & rhs) const
  {
    if (!(this->snapshotid == rhs.snapshotid))
      return false;
    return true;
  }
  bool operator != (const Snapshot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Snapshot & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class Snapshot;
void swap(Snapshot &a, Snapshot &b);

class ReadOptions {
 public:

  static const uint64_t _reflection_id = 1092669993626789804U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  ReadOptions() : verify_checksums(0), fill_cache(0) {
  }

  ReadOptions(const ReadOptions&) = default;
  ReadOptions& operator=(const ReadOptions&) = default;
  ReadOptions(ReadOptions&&) = default;
  ReadOptions& operator=(ReadOptions&&) = default;

  void __clear() {
    verify_checksums = 0;
    fill_cache = 0;
    snapshot.__clear();
    __isset.__clear();
  }

  virtual ~ReadOptions() throw() {}

  bool verify_checksums;
  bool fill_cache;
  Snapshot snapshot;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      verify_checksums = false;
      fill_cache = false;
      snapshot = false;
    }
    bool verify_checksums;
    bool fill_cache;
    bool snapshot;
  } __isset;

  bool operator == (const ReadOptions & rhs) const
  {
    if (!(this->verify_checksums == rhs.verify_checksums))
      return false;
    if (!(this->fill_cache == rhs.fill_cache))
      return false;
    if (!(this->snapshot == rhs.snapshot))
      return false;
    return true;
  }
  bool operator != (const ReadOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReadOptions & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class ReadOptions;
void swap(ReadOptions &a, ReadOptions &b);

class DBHandle {
 public:

  static const uint64_t _reflection_id = 8973827971994157004U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  DBHandle() : dbname(""), handleid(0) {
  }

  DBHandle(const DBHandle&) = default;
  DBHandle& operator=(const DBHandle&) = default;
  DBHandle(DBHandle&&) = default;
  DBHandle& operator=(DBHandle&&) = default;

  void __clear() {
    dbname = "";
    handleid = 0;
    __isset.__clear();
  }

  virtual ~DBHandle() throw() {}

  Text dbname;
  int64_t handleid;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      dbname = false;
      handleid = false;
    }
    bool dbname;
    bool handleid;
  } __isset;

  bool operator == (const DBHandle & rhs) const
  {
    if (!(this->dbname == rhs.dbname))
      return false;
    if (!(this->handleid == rhs.handleid))
      return false;
    return true;
  }
  bool operator != (const DBHandle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DBHandle & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class DBHandle;
void swap(DBHandle &a, DBHandle &b);

class Iterator {
 public:

  static const uint64_t _reflection_id = 11184146435197093740U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  Iterator() : iteratorid(0) {
  }

  Iterator(const Iterator&) = default;
  Iterator& operator=(const Iterator&) = default;
  Iterator(Iterator&&) = default;
  Iterator& operator=(Iterator&&) = default;

  void __clear() {
    iteratorid = 0;
    __isset.__clear();
  }

  virtual ~Iterator() throw() {}

  int64_t iteratorid;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      iteratorid = false;
    }
    bool iteratorid;
  } __isset;

  bool operator == (const Iterator & rhs) const
  {
    if (!(this->iteratorid == rhs.iteratorid))
      return false;
    return true;
  }
  bool operator != (const Iterator &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Iterator & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class Iterator;
void swap(Iterator &a, Iterator &b);

class kv {
 public:

  static const uint64_t _reflection_id = 16082992224095104076U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  kv() {
  }

  kv(const kv&) = default;
  kv& operator=(const kv&) = default;
  kv(kv&&) = default;
  kv& operator=(kv&&) = default;

  void __clear() {
    key.__clear();
    value.__clear();
    __isset.__clear();
  }

  virtual ~kv() throw() {}

  Slice key;
  Slice value;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      key = false;
      value = false;
    }
    bool key;
    bool value;
  } __isset;

  bool operator == (const kv & rhs) const
  {
    if (!(this->key == rhs.key))
      return false;
    if (!(this->value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const kv &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const kv & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class kv;
void swap(kv &a, kv &b);

class ResultItem {
 public:

  static const uint64_t _reflection_id = 13211316281207238796U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  ResultItem() : status(static_cast<Code>(0)) {
  }

  ResultItem(const ResultItem&) = default;
  ResultItem& operator=(const ResultItem&) = default;
  ResultItem(ResultItem&&) = default;
  ResultItem& operator=(ResultItem&&) = default;

  void __clear() {
    status = static_cast<Code>(0);
    value.__clear();
    __isset.__clear();
  }

  virtual ~ResultItem() throw() {}

  Code status;
  Slice value;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      status = false;
      value = false;
    }
    bool status;
    bool value;
  } __isset;

  bool operator == (const ResultItem & rhs) const
  {
    if (!(this->status == rhs.status))
      return false;
    if (!(this->value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const ResultItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultItem & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class ResultItem;
void swap(ResultItem &a, ResultItem &b);

class ResultPair {
 public:

  static const uint64_t _reflection_id = 14875242256166808460U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  ResultPair() : status(static_cast<Code>(0)) {
  }

  ResultPair(const ResultPair&) = default;
  ResultPair& operator=(const ResultPair&) = default;
  ResultPair(ResultPair&&) = default;
  ResultPair& operator=(ResultPair&&) = default;

  void __clear() {
    status = static_cast<Code>(0);
    keyvalue.__clear();
    __isset.__clear();
  }

  virtual ~ResultPair() throw() {}

  Code status;
  kv keyvalue;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      status = false;
      keyvalue = false;
    }
    bool status;
    bool keyvalue;
  } __isset;

  bool operator == (const ResultPair & rhs) const
  {
    if (!(this->status == rhs.status))
      return false;
    if (!(this->keyvalue == rhs.keyvalue))
      return false;
    return true;
  }
  bool operator != (const ResultPair &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultPair & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class ResultPair;
void swap(ResultPair &a, ResultPair &b);

class ResultSnapshot {
 public:

  static const uint64_t _reflection_id = 16627180600575569004U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  ResultSnapshot() : status(static_cast<Code>(0)) {
  }

  ResultSnapshot(const ResultSnapshot&) = default;
  ResultSnapshot& operator=(const ResultSnapshot&) = default;
  ResultSnapshot(ResultSnapshot&&) = default;
  ResultSnapshot& operator=(ResultSnapshot&&) = default;

  void __clear() {
    status = static_cast<Code>(0);
    snapshot.__clear();
    __isset.__clear();
  }

  virtual ~ResultSnapshot() throw() {}

  Code status;
  Snapshot snapshot;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      status = false;
      snapshot = false;
    }
    bool status;
    bool snapshot;
  } __isset;

  bool operator == (const ResultSnapshot & rhs) const
  {
    if (!(this->status == rhs.status))
      return false;
    if (!(this->snapshot == rhs.snapshot))
      return false;
    return true;
  }
  bool operator != (const ResultSnapshot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultSnapshot & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class ResultSnapshot;
void swap(ResultSnapshot &a, ResultSnapshot &b);

class ResultIterator {
 public:

  static const uint64_t _reflection_id = 595886977232564460U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  ResultIterator() : status(static_cast<Code>(0)) {
  }

  ResultIterator(const ResultIterator&) = default;
  ResultIterator& operator=(const ResultIterator&) = default;
  ResultIterator(ResultIterator&&) = default;
  ResultIterator& operator=(ResultIterator&&) = default;

  void __clear() {
    status = static_cast<Code>(0);
    iterator.__clear();
    __isset.__clear();
  }

  virtual ~ResultIterator() throw() {}

  Code status;
  Iterator iterator;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      status = false;
      iterator = false;
    }
    bool status;
    bool iterator;
  } __isset;

  bool operator == (const ResultIterator & rhs) const
  {
    if (!(this->status == rhs.status))
      return false;
    if (!(this->iterator == rhs.iterator))
      return false;
    return true;
  }
  bool operator != (const ResultIterator &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultIterator & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class ResultIterator;
void swap(ResultIterator &a, ResultIterator &b);

class LeveldbException : public apache::thrift::TException {
 public:

  static const uint64_t _reflection_id = 2551220192341843436U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  LeveldbException() : message(""), errorCode(static_cast<Code>(0)) {
  }

  LeveldbException(const LeveldbException&) = default;
  LeveldbException& operator=(const LeveldbException&) = default;
  LeveldbException(LeveldbException&&) = default;
  LeveldbException& operator=(LeveldbException&&) = default;

  void __clear() {
    message = "";
    errorCode = static_cast<Code>(0);
    __isset.__clear();
  }

  virtual ~LeveldbException() throw() {}

  Text message;
  Code errorCode;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      message = false;
      errorCode = false;
    }
    bool message;
    bool errorCode;
  } __isset;

  bool operator == (const LeveldbException & rhs) const
  {
    if (!(this->message == rhs.message))
      return false;
    if (!(this->errorCode == rhs.errorCode))
      return false;
    return true;
  }
  bool operator != (const LeveldbException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LeveldbException & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  virtual const char* what() const throw() {
    return "LeveldbException";
  }

};

class LeveldbException;
void swap(LeveldbException &a, LeveldbException &b);

} // namespace

#endif
